# 7. Внесение изменений

Теперь, когда мы знаем, как работает система отслеживания Git, мы готовы применить наши первые изменения в нашем репозитории.

7.1. **git status** — Показать текущие изменения
Давайте создадим простой файл и добавим его в наш репозиторий. После этого мы выполняем команду `git status` и анализируем ее вывод:
```
$ "Hello World" >> myfile.txt
$ git status
On branch master
Your branch is up to date with 'origin/master'.

Untracked files:
  (use "git add <file>..." to include in what will be committed)
    myfile.txt

nothing added to commit but untracked files present (use "git add" to track)
```
Команда выводит текущий подробный статус наших изменений . Первая часть показывает, синхронизированы ли локальная и удаленная ветки.

Далее в выводе отображается состояние рабочего дерева — список измененных в данный момент файлов со статусом их обслуживания. Как мы видим, файл myfile.txt в настоящее время находится в области рабочего каталога и не отслеживается Git.

7.2. **git add** — отслеживать изменения
Чтобы начать отслеживать изменения, нам нужно переместить их в индекс с помощью команды `git add` :
```
git add myfile.txt
git stage *
```
Мы можем указать сразу несколько файлов, разделив их пробелом. Мы также можем указать все файлы, используя знак звездочки.

В качестве альтернативы мы также можем использовать команду `git stage`, которая является синонимом команды `git add`.

Давайте теперь проверим статус:

```
git status
On branch master
Your branch is up to date with 'origin/master'.

Changes to be committed:
  (use "git restore --staged <file>..." to unstage)
    new file:   myfile.txt
```
Как мы видим, Git начал отслеживать наши файлы.

7.3. **git restore & gitignore** — отменить отслеживание изменений
Git позволяет удалять файлы из индекса . Если мы по ошибке переместили в него свои изменения и хотим временно отключить их отслеживание, используем git restore :
```
git restore -S myfile.txt
git status
On branch master
Your branch is up to date with 'origin/master'.

Untracked files:
  (use "git add <file>..." to include in what will be committed)
    myfile.txt
```
Мы только что снова переместили наш файл в рабочую область и исключили его из дальнейших коммитов до тех пор, пока мы снова не подготовим его. Флаг -S ( –staged ) указывает Git восстановить только индекс репозитория .

Мы также можем навсегда исключить файлы и отключить их отслеживание. Для этого нам нужно создать файл `.gitignore`. Этот файл содержит шаблоны имен файлов и применяется ко всем файлам в текущем каталоге и его дочерних каталогах. Любые дальнейшие действия по добавлению будут игнорировать файлы, соответствующие этим шаблонам.

7.4. *git commit* — сохранить изменения
Давайте вернём последние изменения и снова переместим наш файл в Staging Area :
```
git add myfile.txt
```
Теперь пришло время сохранить нашу работу, поэтому нам нужно сделать **коммит**.

**Коммит — это объект Git, который похож на снимок нашего репозитория в определенное время**.

Чтобы зафиксировать изменения, воспользуемся командой `git commit`:
```
git commit -m "My first commit"
[master 8451901] My first commit
 1 file changed, 1 insertion(+)
 create mode 100644 myfile.txt
```
Мы только что создали наш первый коммит **локально**.

Команда `git commit` содержит множество дополнительных опций для выполнения более сложных операций, которые мы можем проверить с помощью команды `git commit –help`.

Наиболее полезным является флаг `-m` , который указывает **сообщение фиксации, описывающее изменения**, сделанные в текущем моментальном снимке.

**Наконец, давайте проверим статус:**
```
git status
On branch master
Your branch is ahead of 'origin/master' by 1 commit.
  (use "git push" to publish your local commits)

nothing to commit, working tree clean
```
Теперь наше рабочее дерево не содержит никаких дополнительных изменений, но локальный репозиторий содержит больше коммитов, чем его внешний источник. Поэтому, чтобы опубликовать наши изменения, мы должны синхронизировать локальные изменения с источником.

7.5. **git log & git show** — проверка коммитов
После того, как мы создали коммит, мы можем проверить его детали. Коммиты включают множество дополнительных метаданных, таких как автор, временная метка и т. д.

Чтобы распечатать список коммитов текущей ветки, мы используем команду `git log`:
```
git log
commit 845190154ed7a491a6143669c4ce88058fb93f8a (HEAD -> master)
Author: ...
Date: ...

    My first commit

commit 9a1e11ec981b41e4b4b9c245a7a96cd6707f4705 (origin/master, origin/HEAD)
...
```

По умолчанию список показывает историю коммитов текущей ветки в обратном хронологическом порядке.

Каждая запись содержит общие метаданные, такие как идентификатор коммита (уникальная контрольная сумма SHA-1), автор, дата и заданное сообщение.

Когда мы хотим углубиться в отдельный коммит, мы печатаем его детали, используя команду `git show`, за которой следует запрошенный идентификатор коммита:
```
git show 845190154ed7a491a6143669c4ce88058fb93f8a
commit 845190154ed7a491a6143669c4ce88058fb93f8a (HEAD -> master)
Author: ...
Date:...

    My first commit

diff --git a/myfile.txt b/myfile.txt
new file mode 100644
index 0000000..557db03
--- /dev/null
+++ b/myfile.txt
@@ -0,0 +1 @@
+Hello World
```
На этот раз выходные данные также отображают различия, сделанные фиксацией по сравнению с предыдущим снимком с помощью команды `git diff`.

7.6. **git stash** — Отложить изменения
Команда `git stash` временно откладывает сделанные нами изменения , возвращая рабочий каталог в соответствие с фиксацией **HEAD** . Это позволяет нам быстро переключать контекст и начинать работать над чем-то другим.

Давайте создадим еще один файл и добавим его в **Staging Area**. После этого запускаем `git stash`:
```
touch myfile-2.txt
git add *
git stash push
Saved working directory and index state WIP on master: 8451901 My first commit
```
**Теперь давайте попробуем перечислить файл:**

```
ls myfile-2.txt
ls: myfile-2.txt: No such file or directory
```
Мы видим, что теперь файла нет. Это связано с тем, что все ожидающие изменения были удалены из рабочего каталога и сохранены в тайнике.

Мы можем распечатать все спрятанные модификации, используя опцию списка :
```
git stash list
stash@{0}: WIP on master: 8451901 My first commit
```
Поскольку мы не предоставили его описание, тайник по умолчанию указан как **WIP** на… . Мы можем изменить значение по умолчанию на более описательное сообщение, используя флаг -m в командной строке.

**Чтобы проверить его детали, мы используем опцию `show` :**
```
git stash show
 myfile-2.txt | 0
 1 file changed, 0 insertions(+), 0 deletions(-)
```
На выходе выводится информация об изменениях, хранящихся в последнем тайнике.

**Наконец, если мы хотим восстановить изменения, мы используем опцию `pop` :**
```
git stash pop
...
$ ls myfile-2.txt 
myfile-2.txt
```
Мы только что удалили одно спрятанное состояние из списка и применили его поверх текущего состояния.
