# 8. Управление историей коммитов
Теперь, когда мы научились сохранять изменения в репозитории, давайте изменим ранее сохраненные коммиты. В следующих разделах мы рассмотрим наиболее распространенные варианты использования.

8.1. **git commit –amend** — добавить дополнительные изменения в коммит
Предположим, мы забыли включить файл при фиксации изменения. Конечно, мы можем создать еще один коммит поверх последнего, но это может запутать историю изменений.

В таких случаях мы можем захотеть, чтобы Git переписал нашу последнюю фиксацию и включил файл, который мы забыли, используя опцию исправления .

**Давайте рассмотрим последний коммит:**
```
git show --summary
commit 845190154ed7a491a6143669c4ce88058fb93f8a (HEAD -> master)
Author: ...
Date: ...

    My first commit

 create mode 100644 myfile.txt
```
Получив наш файл my-file2.txt, давайте зафиксируем его, используя опцию исправления :
```
git commit --amend
[master 0ed9f03] My first commit
 2 files changed, 1 insertion(+)
 create mode 100644 myfile-2.txt
 create mode 100644 myfile.txt
```
Мы можем заметить, что Git добавил файл в нашу последнюю фиксацию, объединив изменения.

8.2. **git rebase** — повторное применение коммитов
Более продвинутый способ изменения коммитов — использование команды `git rebase`. Он повторно применяет коммиты из истории поверх другой базы , что позволяет нам изменять их на лету.

**Давайте создадим еще один коммит в нашем репозитории:**
```
touch myfile-3.txt
git add *
git commit -m "My second commit"
```
Теперь у нас должно быть два одиночных коммита — Мой первый коммит и Мой второй коммит .

Начнем перебазировать оба коммита в интерактивном режиме:
```
git rebase -i HEAD~2
```
Откроется редактор, в котором мы можем манипулировать историей с помощью команд:
```
pick 82d8635 My first commit
pick 6d58108 My second commit

# Rebase 9a1e11e..82d8635 onto 9a1e11e (2 commands)
#
# Commands:
# p, pick <commit> = use commit
# r, reword <commit> = use commit, but edit the commit message
# e, edit <commit> = use commit, but stop for amending
# s, squash <commit> = use commit, but meld into previous commit
# d, drop <commit> = remove commit 
...
```
Вверху у нас есть список коммитов ребазинга, за которым следует руководство. У нас есть много вариантов здесь. Мы можем изменить порядок, поменяв местами строки, или перефразировать сообщение коммита, или сжать их в одно, отредактировать или даже удалить один коммит. Строки инструкций будут применяться сверху вниз.

8.3. **git reset** — откат к определенному состоянию
Иногда нам может понадобиться отказаться от текущего состояния и вернуться к историческому моментальному снимку. Для этого воспользуемся опцией `git reset`:
```
git reset 82d8635
```
Он отменяет все фиксации после указанной фиксации , сохраняя изменения локально и перемещая их в **Staging Area**. Но если мы хотим отказаться от всех рабочих изменений, мы можем использовать флаг `–hard`.

[Вернуться назад](../readme.md)